from Crypto.PublicKey import RSA
from Crypto.Util.number import bytes_to_long, long_to_bytes, inverse
from crt import EEA
import sys

import math

import gmpy2

sys.setrecursionlimit(15000)

# firstly, read our ciphers and keys

ciphers = []

with open('ciphers') as f:
    for line in f:
        ciphers.append(int(line))

print(ciphers)

f1 = open('key1.pem', 'r')
key1 = RSA.import_key(f1.read())

f2 = open('key2.pem', 'r')
key2 = RSA.import_key(f2.read())

assert (key1.n == key2.n)

# we know: c_i = m^(e_i) mod n, i = 1, 2

# compute extended Euclid: s*e_1 + t*e_2 = 1

d, s, t = EEA(key1.e, key2.e)

print(f"key1.n: {key1.n}, key1.e: {key1.e}, key2.e: {key2.e}, gcd(e1,e2): {math.gcd(key1.e, key2.e)}")

# compute modular inverse of c_1 mod n

c_1_inv = inverse(ciphers[0], key1.n)

m = pow(c_1_inv, abs(s), key1.n)*pow(ciphers[1], t, key1.n)

print(m % key1.n)

root = gmpy2.iroot(m % key1.n, 17)

print(long_to_bytes(root[0]).decode(errors="ignore"))
