import math
from sympy import nextprime
from Crypto.Random import get_random_bytes
from Crypto.PublicKey import RSA
# from secret import flag
from Crypto.Cipher import PKCS1_OAEP
from Crypto.Util.number import inverse, long_to_bytes, bytes_to_long
from binascii import hexlify
import wiener
import sys

sys.setrecursionlimit(15000)


key1 = RSA.import_key(open('key1.pem', 'rb').read())
key2 = RSA.import_key(open('key2.pem', 'rb').read())

print(f'key1.n: {key1.n}, key1.e: {key1.e}, key2.n: {key2.n}, key2.e: {key2.e}, key1.n==key2.n: {key1.n==key2.n}')

cryptor1 = PKCS1_OAEP.new(key1)

cryptor2 = PKCS1_OAEP.new(key2)

# try to crack the keys using Wiener attack
d1 = wiener.attack(key1.e, key1.n)
d2 = wiener.attack(key2.e, key2.n)

# success for first key; for the second I'd say we can somehow derive it from what we already have?
if d1 is None:
    print("Failed")
else:
    print("Hacked d1={}".format(d1))

if d2 is None:
    print("Failed")
else:
    print("Hacked d2={}".format(d2))

privkey1 = RSA.construct((key1.n, key1.e, d1))

decryptor1 = PKCS1_OAEP.new(privkey1)

c1 = 0x3b6ccd7fa1de0455945998bc024adc6c2b60ccc8f020cbf024c3d4f98eafdf6a43afd15ec4d9a32f84cb61f7a5462547f2e3622b547c3e9ccb723102805544b373a80f4d252a1081db6d5c5499b222093fd4bb7997c68ab0ed8a9ac3bd0dae64cdfb946da1e311ef6e216ddf2dac14ea3710d5622269f08073598c24a3000a6dd6270ca0db5c304102bc9a5cd104484a2c0ced339121f13499c795de343ad2e655d4ace726654ee9f110e4bee3db95d8e514bd6e658769a01638ff2e9ce954dc09def3b01f6d598ddae2ca9735c8e8f9b71c96984a114084fb0a25b3646481e8c8d4d8adfedc7afad7be7a009c6d12753db4216ab9fd7fc8c37c819aef6a8bce

decrypted1 = decryptor1.decrypt(long_to_bytes(c1))

print(decrypted1.decode())

# now factor n given d
# function from https://ctftime.org/writeup/18177

def find_prime_factors(n, e, d):
    k = e * d - 1
    s = 0
    t = k

    while t % 2 == 0:
        t = t // 2
        s += 1

    i = s
    a = 2

    while True:
        b = pow(a, t, n)

        if b == 1:
            a = nextprime(a)
            continue

        while i != 1:
            c = pow(b, 2, n)
            if c == 1:
                break
            else:
                b = c
                i -= 1

        if b == n - 1:
            a = nextprime(a)
            continue

        p = math.gcd(b-1, n)
        q = n // p
        return p, q


p, q = find_prime_factors(key1.n, key1.e, d1)

print(f'Prime factors of n: p = {p}, q = {q}')

# now we can find the modular inverse of key2.d wrt (p-1)(q-1)
# and decrypt c2

d2 = inverse(key2.e, (p-1)*(q-1))

privkey2 = RSA.construct((key2.n, key2.e, d2))

decryptor2 = PKCS1_OAEP.new(privkey2)

c2 = 0x998d5eeb0c048ade8cd807cb582b15a7799e8481a7476dbe8e0310b5ffc5161add92539bc0a374333c11f5f2008195782a44e45f2394fe3115af59fbc73ad24c4d084d79ba8e5896b644917335fd9a0e07c1d1d316e50480ba44c67b6fc04a2ce33dbc721768f1f874ff2ce1ec0503a4a7c67d10119ff9f79030459068de24ff24593e16877fd74c5a12d0e64a3d62e61b13c403aad2fe605601e8a097aba99707e305e3125a3c89f3d6beccc2f19a32fdac9ab7df181938b9b80d83a54c9c23ef11affff0fca67ecd9d45c58ece90a44ecd60aff7be05bf97cb554c563a3f9139d99f7c76a07acaaa261b1d6cb41e228fb2aca02ed1c64d468aabb8cfaa9210

decrypted2 = decryptor2.decrypt(long_to_bytes(c2))

print(decrypted2.decode())
