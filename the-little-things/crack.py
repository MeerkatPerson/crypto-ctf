import gmpy2
from Crypto.PublicKey import RSA
from Crypto.Util.number import bytes_to_long, long_to_bytes, inverse

import math

from bitarray import bitarray

c1 = 42336544435253933536571954838660210456673799313946223624027748088061726718572299139363851055238375511845910038334901089313

c2 = 33204532065272468154568031379494217020196224826457640866102638541263710694078212055225472329514290429192429791487345915972554443224279747706553789226113371254588526054567246462263518872974423031547382595587243560479107049098397758081581365340308958896474273547806440345436978234135905015219728337520986567494221142318548110054859569291241827884447450390989247586047890414688097826185038782133498190774245438922562220556613773646965174122498284917522528644308132941505845897051662733687885538622579906358733463150621672945904186249638099464377998115215308222055231287099948324881079578846541080902765278182644966145586775208766552885707868966048245332013689201184751928866423591896102608741588192661003433424534843601003631162912851850479001373390133493920718471426253505319466315730592496803467704131158517160083514785453824293743002877565136874744852618642868754329531470691313305645956200579851490468877063019233545805249759729099632636728009736087498535067919405285636494611262147162831794199038526318119852062046755712480035628444319761371264826504848623185879239838813948080428241397101515457927429713176464815804827011433040374181029729369670892547828952636150088908657845842087990118571090102523800955406080025291812377145402

f = open('pubkey.pem', 'r')

key = RSA.import_key(f.read())


# First message easy: as chunks are short and no padding whatsoever is applied in this case, given that e is just 3 m1^3 will likely be smaller than n, so we can simply take the third root.

m1 = int((gmpy2.iroot(c1, 3))[0])

print(long_to_bytes(m1).decode())

# Second message: also easy, since m2 was simply multiplied with a fixed number

r = 440207993569202145226583596168668480279612819965794541699444606998884126327457148126985393713331187326269759129786151827315472662545169229810947283583185940188753204507272015410292547991341421865580434571907487831150551894581100517979422062705719326708845893428059355370710948150227146186294791368354716644074593401065391186346804909062169792789820494220878930621918113842522702840719980702035210790221375054988484360489658798914894297868096164068410349956337623656160859441076123257680687409511415929920760564728135223020626088404535712263440453673827848602042008666139187037894104559208209842699418459046227548274369494390325913146860043311029683073260582295749123383864290580535513555624777329124481863968842759997800343985031020803958083752044340070928621625315960187682219676298491723091409452028712084469300912870666232227855276035007617694078713741109322804779068398754913109357219461822870410839177245857661666072743515936844588884933042735358697038815104339349515893292336683598862297813136372910247113611321570981701692485394194808371648912273085184798875264734186133928625551638315540870469114902162342732282838097849696596328601119607487566568239039051073511095284994830149350910188968078336841520356458362003852374562021

r_inv = pow(inverse(r, key.n), 3)

c2_ = (r_inv * c2) % key.n

m2 = int((gmpy2.iroot(c2_, 3))[0])

print(long_to_bytes(m2).decode())

# On to the third chunk, gargh!!

c3 = 111015753290406319313645132076785737607066806879362063841206504518839817972360157540101026381184861618504490354102610969113343992155955669873856433425970817512437518456812101182113670903210492017712839235616933044944451346764915700365610116636028868624756005668610633590419922114008320826479333073920026084675347312076634819404561060615069344604735280835584682850810354069353877913255234746776605874542698393299947022419720693886595443366440206394190735893596895093452901578343165344978811067108358400577110813869471382677112971458335876189954681462164917209554329543075938728783197149907613426725913122528902736644739248648802290622335386422578466434043787522250701993116356482328662839297158831430620800192731021770509253293986815434838829566684206126473331476515895014152556872448350513680707520565271264156770669642124119767144127338346885955435975113881849609161267877187398708731534101769532499324873896267144420713992785072215162721756463195738575909559325388918070535183144920846146991291213921442948165244566235744507927625774451652585090122177246672570357051663422972590367482941296986489822575363385607721604077477117449104787663938158176441773016322964674877835750027831670883418637235424667734213633005806149614689958046

# This one is not that difficult either: we pad with all zeroes, i.e., we multiply by a power of two.

bytelength = int(math.floor(math.log2(key.n))) // 8

k = (bytelength - len("flag{th3re_4re_ma".encode()))*8

r2 = pow(2, k, key.n)

r2_inv = inverse(r2, key.n)

r2_inv_pow = pow(r2_inv, 3, key.n)

c3_ = (r2_inv_pow * c3) % key.n

m3 = int((gmpy2.iroot(c3_, 3))[0])

print(long_to_bytes(m3).decode())

# On to the fourth! Now we pad by repeating the message many times.

c4 = 176669016645859261762038998499101186352807651130383356518378341991253444191038890742395207564173300705688406928337477626469464274290751847397015671156597606097420308899116855508953157546970930803636838823714364707963754092349100849204630261622726965600373202035226957987981984126009483825971200270970055797814130985772455391756100425590275296963721456305054721858535598464527031384475412557615164368705562578765839202969904596657416144505223966619698970572535462655822459428181509593426244321295666757664893950533346922526109419129064169244238571163485431564587409627181779260391101523046077576996686847108250360113224415769777267999983222429130284659893810280007471405318889837800051196201518639142134539175297731477004151052296408120821027160159840994135239381973186530552743507779345768903892001112573949149073946669744867886449289014481247084489696656840246745209632427260211825387439251517616708771927800133259151965853647034919308770675497737851188717730249000659119772102387570582078953818163607314640449261841517009736820732856797161601324431014057719587557781366628259568024829247079938334260248443771681971557810188130008293920341345517169781711868182561014216120038460856173169352543785140192599723022099613025528468358519


def encrypt4(message):
    bytelength = int(math.floor(math.log2(key.n))) // 8
    msg = message * (bytelength // len(message))
    # print(f'msg length: {len(msg)}')
    return pow(bytes_to_long(msg), key.e, key.n)


# for k in range(1, math.ceil(math.log2(key.n))):

times = bytelength // len("flag{th3re_4re_ma".encode())

# times = bytelength // k

# itlen = math.ceil(math.log2(bytes_to_long("flag{th3re_4re_ma".encode())))

# bitlen = (len("flag{th3re_4re_ma".encode()) * 8)

bitlen = len("flag{th3re_4re_ma".encode())*8

# bitlen = math.ceil(math.log2(pow(2, k)))

# print(f'bitlen: {bitlen}')

bit_array = bitarray(bitlen)

bit_array.setall(0)

bit_array[bitlen-1] = 1

one = bitarray(1)

one[0] = 1

r_arr = one + (bit_array*(times-1))

# print(r_arr)

r4 = 0
for bit in r_arr:
    r4 = (r4 << 1) | bit

# print(r4)

# print(bin(r4))

msg_long = bytes_to_long(("flag{th3re_4re_ma").encode())

# print(long_to_bytes(msg_long*r4).decode())

# print(f'bytelen: {bytelength}, msg_long*r4: {len(long_to_bytes(msg_long*r4))}')

# print(f'r4: {r4}, r4 < n? {r4 < key.n}, n - r4: {key.n - r4}')

r4_inv = inverse(r4, key.n)

r4_inv_pow = pow(r4_inv, 3, key.n)

# c_test = encrypt4(("flag{th3re_4re_ma").encode())

# c_test_ = (r4_inv_pow * c_test) % key.n

# m_test = int((gmpy2.iroot(c_test_, 3))[0])

c4_ = (r4_inv_pow * c4) % key.n

m4 = int((gmpy2.iroot(c4_, 3))[0])

print(long_to_bytes(m4).decode(encoding="utf8", errors='ignore'))

# Number 5: Coppersmith?

c5 = 150316221346267410809216070631265577086647557255058978693263311834040361385979497939787148253420228265933080571063280549683411131490785489852208513970022036030235510619505070560577640482525517230800827924735797768551631999861118565792087588883442076639503614731900126192288101922336790671418167094212566425730755125929063230544055307991569286648346607082560714457783349430844444145853070020681895128323940108584047554689456198211384302643882944203443693459353490525095399308591382807873827153271709751145340918931921199809392574257515083811547551542381554450667507463129242842991773644466565709541408007035822441182819491031151966390600637556944001635885753813063412025476129776667311057753580671114137006914234280743626227222830715489325843692514422284862160327577479086764156789594150174553517173605750943941902261404346141672823080630279339009650326949968080668950346180042634744298651493598267628791173827410572328914438586280062669782155473274426815377878548397379333861631786919400859072328244456494301813534046435446551650327818224688703576046240455159104816380469339682093535453062728098204705863882133798533770246448205773182674554718696384672858950116344665134759750209246641621568800496128665417235039148922362657797221511

pad_len = (bytelength - len("flag{th3re_4re_ma".encode()))

key_len = math.floor(math.log2(key.n))

# Our polynomial is ....

bitlen_ = math.ceil(math.log2(bytes_to_long("flag{th3re_4re_ma".encode())))

"""
print(
    f'keylen: {key_len}, bitlen: {bitlen_}, bytelen: {len(("ny_vers1ons_0f_th").encode())}')
"""

# f(x) = (2 ** key_len - 2 ** bitlen + x)^3 - c5

# respectively .... (this will most likely NOT work)

# msg_long = 87112285919352821485011233722547383070077

msg_long = 7874984442039004643961972223357


def pad(message):
    bytelength = int(math.floor(math.log2(key.n))) // 8
    msg = b'\xff' * (bytelength - len(message)) + message
    return msg


print(long_to_bytes(msg_long).decode())

# encoding="utf8", errors='ignore'
